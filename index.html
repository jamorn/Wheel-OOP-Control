<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wheel Responsive UI Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #111; touch-action: none; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 12px;
            pointer-events: none;
            width: calc(100% - 40px);
            max-width: 400px;
            border-left: 8px solid #00ff88;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        /* ปรับขนาด UI สำหรับจอเล็ก (Mobile) */
        @media (max-width: 600px) {
            #info {
                padding: 10px;
                top: 5px;
                left: 5px;
                width: calc(100% - 30px);
                max-width: none;
                border-left-width: 5px;
            }
            #info h2 { font-size: 1.1em !important; }
            .status-badge { font-size: 1.1em !important; padding: 8px !important; }
            .code-snippet, .prev-code-snippet { font-size: 0.85em !important; padding: 8px !important; }
        }
        .code-snippet {
            color: #ffcc00;
            font-family: 'Courier New', Courier, monospace;
            display: block;
            margin-top: 8px;
            background: rgba(255, 204, 0, 0.15);
            padding: 12px;
            border-radius: 6px;
            font-size: 1.1em;
            font-weight: bold;
            border: 1px solid rgba(255, 204, 0, 0.3);
            word-break: break-all;
        }
        .prev-code-snippet {
            color: #ff4444;
            font-family: 'Courier New', Courier, monospace;
            display: block;
            margin-top: 8px;
            background: rgba(255, 68, 68, 0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 1em;
            opacity: 0.9;
            border: 1px solid rgba(255, 68, 68, 0.2);
            word-break: break-all;
        }
        .cmd-label { font-size: 0.75em; opacity: 0.8; margin-bottom: 2px; display: block; }
        .cmd-value { display: block; }

        .status-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 5px;
        }
        .status-badge {
            display: block;
            padding: 12px;
            border-radius: 8px;
            font-size: 1.3em;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        .current { background: #00ff88; color: #000; font-weight: bold; }
        .previous { background: #333; color: #aaa; }
        .label { font-size: 0.75em; color: #aaa; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 1px; }
        hr { border: 0; border-top: 1px solid #444; margin: 15px 0; }
    </style>
</head>
<body>
    <div id="info">
        <h2 style="margin-top:0; font-size: 1.5em; color: #00ff88;">Wheel Step Visualizer</h2>
        
        <div class="label">Rotation Y (Steering)</div>
        <div class="status-container">
            <div class="status-badge current" id="currentY">0°</div>
            <div class="status-badge previous" id="prevY">Prev: 0°</div>
        </div>

        <div class="label" style="margin-top:10px;">Rotation X (Rolling)</div>
        <div class="status-container">
            <div class="status-badge current" id="currentX">90°</div>
            <div class="status-badge previous" id="prevX">Prev: 90°</div>
        </div>

        <hr>
        
        <p style="margin:0; font-size: 0.85em; color: #00ff88; font-weight: bold;">Current Command:</p>
        <div id="lastCommand" class="code-snippet">
            <span class="cmd-label" id="lastCmdDeg">Rotate to 90°</span>
            <span class="cmd-value" id="lastCmdMath">mesh.rotation.x = Math.PI / 2</span>
        </div>
        
        <p style="margin:10px 0 0 0; font-size: 0.85em; color: #ff4444; font-weight: bold;">Previous Command:</p>
        <div id="prevCommand" class="prev-code-snippet">
            <span class="cmd-label" id="prevCmdDeg">Unknown</span>
            <span class="cmd-value" id="prevCmdMath">-</span>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        class Wheel {
            constructor(radius = 1, thickness = 0.4) {
                this.radius = radius;
                this.group = new THREE.Group();
                
                this.history = { x: Math.PI/2, y: 0 };
                this.lastCommand = { deg: "Rotate X to 90°", math: "mesh.rotation.x = Math.PI / 2" };
                this.prevCommand = { deg: "Unknown", math: "-" };

                const geometry = new THREE.CylinderGeometry(radius, radius, thickness, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.1 });
                this.mesh = new THREE.Mesh(geometry, material);

                const edgeGeo = new THREE.EdgesGeometry(geometry);
                const wireframe = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.5 }));
                this.mesh.add(wireframe);

                const marker = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, thickness + 0.1, 0.4),
                    new THREE.MeshBasicMaterial({ color: 0xff3333 })
                );
                marker.position.set(radius - 0.1, 0, 0);
                this.mesh.add(marker);

                this.ghost = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 }));
                this.ghost.rotation.x = Math.PI / 2;
                this.ghost.visible = false;

                this.mesh.rotation.x = Math.PI / 2;
                this.group.position.y = radius;
                
                this.group.add(this.mesh);
                this.group.add(this.ghost);
            }

            stepY(direction = 1) {
                this.saveHistory();
                const step = (Math.PI / 2) * direction;
                this.mesh.rotation.y += step;
                const degChange = direction > 0 ? "+90°" : "-90°";
                const mathChange = direction > 0 ? "Math.PI / 2" : "-Math.PI / 2";
                this.updateUI(`Turn Y ${degChange}`, `mesh.rotation.y += ${mathChange}`);
            }

            stepX(direction = 1) {
                this.saveHistory();
                const step = (Math.PI / 2) * direction;
                this.mesh.rotation.x += step;
                const degChange = direction > 0 ? "+90°" : "-90°";
                const mathChange = direction > 0 ? "Math.PI / 2" : "-Math.PI / 2";
                this.updateUI(`Roll X ${degChange}`, `mesh.rotation.x += ${mathChange}`);
            }

            saveHistory() {
                this.history.x = this.mesh.rotation.x;
                this.history.y = this.mesh.rotation.y;
                this.prevCommand = { ...this.lastCommand };
                
                this.ghost.rotation.copy(this.mesh.rotation);
                this.ghost.visible = true;
            }

            updateUI(degText, mathText) {
                if(degText && mathText) {
                    this.lastCommand = { deg: degText, math: mathText };
                }

                const toDeg = (rad) => {
                    let deg = Math.round((rad * 180) / Math.PI) % 360;
                    return deg < 0 ? deg + 360 : deg;
                };

                document.getElementById('currentY').innerText = `${toDeg(this.mesh.rotation.y)}°`;
                document.getElementById('prevY').innerText = `Prev: ${toDeg(this.history.y)}°`;
                
                document.getElementById('currentX').innerText = `${toDeg(this.mesh.rotation.x)}°`;
                document.getElementById('prevX').innerText = `Prev: ${toDeg(this.history.x)}°`;
                
                // Update Current Command
                document.getElementById('lastCmdDeg').innerText = this.lastCommand.deg;
                document.getElementById('lastCmdMath').innerText = this.lastCommand.math;
                
                // Update Previous Command
                document.getElementById('prevCmdDeg').innerText = this.prevCommand.deg;
                document.getElementById('prevCmdMath').innerText = this.prevCommand.math;
            }

            reset() {
                this.lastCommand = { deg: "Reset X to 90°", math: "mesh.rotation.x = Math.PI / 2" };
                this.prevCommand = { deg: "Unknown", math: "-" };
                
                this.mesh.rotation.set(Math.PI / 2, 0, 0);
                this.ghost.visible = false;
                this.history = { x: Math.PI/2, y: 0 };
                this.updateUI();
            }
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 3);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        scene.add(new THREE.GridHelper(10, 20, 0x444444, 0x222222));

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(5, 10, 7);
        scene.add(mainLight);

        const fillLight = new THREE.PointLight(0xffffff, 1.0);
        fillLight.position.set(-5, 2, -5);
        scene.add(fillLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
        scene.add(hemiLight);

        const myWheel = new Wheel(1, 0.4);
        scene.add(myWheel.group);

        // --- เพิ่มฟังก์ชัน Professional Axes ---
        let axesGroup;
        function setupProfessionalAxes() {
            axesGroup = new THREE.Group();
            const origin = new THREE.Vector3(0, 0.05, 0); // ยกขึ้นจาก Grid เล็กน้อย
            const size = 4;
            
            const xColor = 0x800080; // ม่วง
            const yColor = 0x00ff00; // เขียว
            const zColor = 0x0000ff; // น้ำเงิน

            // Arrow Helpers
            const xArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), origin, size, xColor, 0.5, 0.2);
            const yArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), origin, size, yColor, 0.5, 0.2);
            const zArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), origin, size, zColor, 0.5, 0.2);
            
            axesGroup.add(xArrow, yArrow, zArrow);

            // Sprite Labels (X, Y, Z)
            function createLabel(text, color) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color;
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.8, 0.8, 1);
                return sprite;
            }

            const xLabel = createLabel('X', '#b19cd9');
            xLabel.position.set(origin.x + size + 0.5, origin.y, origin.z);
            
            const yLabel = createLabel('Y', '#00ff00');
            yLabel.position.set(origin.x, origin.y + size + 0.5, origin.z);
            
            const zLabel = createLabel('Z', '#0000ff');
            zLabel.position.set(origin.x, origin.y, origin.z + size + 0.5);

            axesGroup.add(xLabel, yLabel, zLabel);
            
            // ทำให้มองเห็นทะลุได้ (X-Ray Effect)
            axesGroup.children.forEach(child => {
                if(child.line) child.line.material.depthTest = false;
                if(child.cone) child.cone.material.depthTest = false;
                if(child.material) child.material.depthTest = false;
                child.renderOrder = 999;
            });

            scene.add(axesGroup);
        }

        setupProfessionalAxes();

        const gui = new GUI({ title: 'CONTROL PANEL' });
        
        // Settings Folder สำหรับ Toggle ต่างๆ
        const settingsFolder = gui.addFolder('VISUAL SETTINGS');
        const settings = {
            showAxes: true
        };
        settingsFolder.add(settings, 'showAxes').name('Show X,Y,Z Axes').onChange((val) => {
            axesGroup.visible = val;
        });
        settingsFolder.open();

        const stepFolder = gui.addFolder('STEP 90 DEGREE');
        const stepActions = {
            rollForward: () => myWheel.stepX(1),
            rollBackward: () => myWheel.stepX(-1),
            turnRight: () => myWheel.stepY(-1),
            turnLeft: () => myWheel.stepY(1)
        };
        stepFolder.add(stepActions, 'rollForward').name('X: กลิ้งไปหน้า (+90°)');
        stepFolder.add(stepActions, 'rollBackward').name('X: กลิ้งถอยหลัง (-90°)');
        stepFolder.add(stepActions, 'turnRight').name('Y: เลี้ยวขวา (-90°)');
        stepFolder.add(stepActions, 'turnLeft').name('Y: เลี้ยวซ้าย (+90°)');
        stepFolder.open();

        const manualFolder = gui.addFolder('MANUAL EDIT');
        manualFolder.add(myWheel.mesh.rotation, 'x', 0, Math.PI * 4).name('Rotation X').listen().onChange(() => myWheel.updateUI('Manual X Edit', `mesh.rotation.x = ${myWheel.mesh.rotation.x.toFixed(2)}`));
        manualFolder.add(myWheel.mesh.rotation, 'y', -Math.PI, Math.PI).name('Rotation Y').listen().onChange(() => myWheel.updateUI('Manual Y Edit', `mesh.rotation.y = ${myWheel.mesh.rotation.y.toFixed(2)}`));
        
        gui.add(myWheel, 'reset').name('RESET TO DEFAULT');

        function checkDevice() {
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                gui.close();
                if (window.innerWidth < 450) {
                    gui.width = window.innerWidth * 0.8;
                }
            } else {
                gui.open();
                gui.width = 300;
            }
        }

        checkDevice();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            checkDevice();
        });
    </script>
</body>
</html>
