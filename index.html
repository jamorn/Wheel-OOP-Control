<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Three.js Wheel OOP - Responsive UI Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #111; touch-action: none; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 12px;
            pointer-events: none;
            width: calc(100% - 40px);
            max-width: 400px;
            border-left: 8px solid #00ff88;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        /* ปรับขนาด UI สำหรับจอเล็ก (Mobile) */
        @media (max-width: 600px) {
            #info {
                padding: 10px;
                top: 5px;
                left: 5px;
                width: calc(100% - 30px);
                max-width: none;
                border-left-width: 5px;
            }
            #info h2 { font-size: 1.1em !important; }
            .status-badge { font-size: 1.1em !important; padding: 8px !important; }
            .code-snippet, .prev-code-snippet { font-size: 0.85em !important; padding: 8px !important; }
        }
        .code-snippet {
            color: #ffcc00;
            font-family: 'Courier New', Courier, monospace;
            display: block;
            margin-top: 8px;
            background: rgba(255, 204, 0, 0.15);
            padding: 12px;
            border-radius: 6px;
            font-size: 1.1em;
            font-weight: bold;
            border: 1px solid rgba(255, 204, 0, 0.3);
            word-break: break-all;
        }
        .prev-code-snippet {
            color: #ff4444;
            font-family: 'Courier New', Courier, monospace;
            display: block;
            margin-top: 8px;
            background: rgba(255, 68, 68, 0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 1em;
            opacity: 0.9;
            border: 1px solid rgba(255, 68, 68, 0.2);
            word-break: break-all;
        }
        .status-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 5px;
        }
        .status-badge {
            display: block;
            padding: 12px;
            border-radius: 8px;
            font-size: 1.3em;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        .current { background: #00ff88; color: #000; font-weight: bold; }
        .previous { background: #333; color: #aaa; }
        .label { font-size: 0.75em; color: #aaa; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 1px; }
        hr { border: 0; border-top: 1px solid #444; margin: 15px 0; }
    </style>
</head>
<body>
    <div id="info">
        <h2 style="margin-top:0; font-size: 1.5em; color: #00ff88;">Wheel Step Visualizer</h2>
        
        <div class="label">Rotation Y (Steering)</div>
        <div class="status-container">
            <div class="status-badge current" id="currentY">0°</div>
            <div class="status-badge previous" id="prevY">Prev: 0°</div>
        </div>

        <div class="label" style="margin-top:10px;">Rotation X (Rolling)</div>
        <div class="status-container">
            <div class="status-badge current" id="currentX">90°</div>
            <div class="status-badge previous" id="prevX">Prev: 90°</div>
        </div>

        <hr>
        
        <p style="margin:0; font-size: 0.85em; color: #00ff88; font-weight: bold;">Current Command:</p>
        <span id="lastCommand" class="code-snippet">mesh.rotation.x = Math.PI / 2</span>
        
        <p style="margin:10px 0 0 0; font-size: 0.85em; color: #ff4444; font-weight: bold;">Previous Command:</p>
        <span id="prevCommand" class="prev-code-snippet">Unknown</span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        class Wheel {
            constructor(radius = 1, thickness = 0.4) {
                this.radius = radius;
                this.group = new THREE.Group();
                
                this.history = { x: Math.PI/2, y: 0 };
                this.lastCommandText = "mesh.rotation.x = Math.PI / 2";
                this.prevCommandText = "Unknown";

                const geometry = new THREE.CylinderGeometry(radius, radius, thickness, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.1 });
                this.mesh = new THREE.Mesh(geometry, material);

                const edgeGeo = new THREE.EdgesGeometry(geometry);
                const wireframe = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.5 }));
                this.mesh.add(wireframe);

                const marker = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, thickness + 0.1, 0.4),
                    new THREE.MeshBasicMaterial({ color: 0xff3333 })
                );
                marker.position.set(radius - 0.1, 0, 0);
                this.mesh.add(marker);

                this.ghost = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 }));
                this.ghost.rotation.x = Math.PI / 2;
                this.ghost.visible = false;

                this.mesh.rotation.x = Math.PI / 2;
                this.group.position.y = radius;
                
                this.group.add(this.mesh);
                this.group.add(this.ghost);
            }

            stepY(direction = 1) {
                this.saveHistory();
                const step = (Math.PI / 2) * direction;
                this.mesh.rotation.y += step;
                this.updateUI(`mesh.rotation.y += Math.PI / 2`);
            }

            stepX(direction = 1) {
                this.saveHistory();
                const step = (Math.PI / 2) * direction;
                this.mesh.rotation.x += step;
                this.updateUI(`mesh.rotation.x += Math.PI / 2`);
            }

            saveHistory() {
                this.history.x = this.mesh.rotation.x;
                this.history.y = this.mesh.rotation.y;
                this.prevCommandText = this.lastCommandText;
                
                this.ghost.rotation.copy(this.mesh.rotation);
                this.ghost.visible = true;
            }

            updateUI(cmdText) {
                if(cmdText) {
                    this.lastCommandText = cmdText;
                }

                const toDeg = (rad) => {
                    let deg = Math.round((rad * 180) / Math.PI) % 360;
                    return deg < 0 ? deg + 360 : deg;
                };

                document.getElementById('currentY').innerText = `${toDeg(this.mesh.rotation.y)}°`;
                document.getElementById('prevY').innerText = `Prev: ${toDeg(this.history.y)}°`;
                
                document.getElementById('currentX').innerText = `${toDeg(this.mesh.rotation.x)}°`;
                document.getElementById('prevX').innerText = `Prev: ${toDeg(this.history.x)}°`;
                
                document.getElementById('lastCommand').innerText = this.lastCommandText;
                document.getElementById('prevCommand').innerText = this.prevCommandText;
            }

            reset() {
                this.saveHistory();
                this.lastCommandText = 'mesh.rotation.set(Math.PI/2, 0, 0)';
                
                this.mesh.rotation.set(Math.PI / 2, 0, 0);
                this.ghost.visible = false;
                this.history = { x: Math.PI/2, y: 0 };
                this.updateUI();
            }
        }

        const scene = new THREE.Scene();
        // ปรับสีพื้นหลังให้สว่างขึ้นเล็กน้อยจาก 0x050505 เป็น 0x111111 เพื่อลดคอนทราสต์ที่มืดเกินไป
        scene.background = new THREE.Color(0x111111);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 3);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // เพิ่ม Exposure เพื่อความสว่างโดยรวม
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Grid
        scene.add(new THREE.GridHelper(10, 20, 0x444444, 0x222222));

        // --- เพิ่มความสว่างของแสง (Lighting Update) ---
        // 1. Ambient Light: เพิ่มจาก 0.6 เป็น 1.0 เพื่อความสว่างในเงามืด
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        // 2. Main Directional Light: ปรับตำแหน่งและเพิ่มความเข้ม
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
        mainLight.position.set(5, 10, 7);
        scene.add(mainLight);

        // 3. Fill Light: แสงเสริมจากด้านล่าง/ด้านหลังเพื่อให้เห็นขอบวัตถุชัดขึ้น
        const fillLight = new THREE.PointLight(0xffffff, 1.0);
        fillLight.position.set(-5, 2, -5);
        scene.add(fillLight);

        // 4. Hemisphere Light: ช่วยให้สีสันดูเป็นธรรมชาติมากขึ้น (ท้องฟ้า/พื้นดิน)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
        scene.add(hemiLight);

        const myWheel = new Wheel(1, 0.4);
        scene.add(myWheel.group);

        // --- Responsive UI Logic ---
        const gui = new GUI({ title: 'CONTROL PANEL' });
        
        const stepFolder = gui.addFolder('STEP 90 DEGREE');
        const stepActions = {
            rollForward: () => myWheel.stepX(1),
            rollBackward: () => myWheel.stepX(-1),
            turnRight: () => myWheel.stepY(-1),
            turnLeft: () => myWheel.stepY(1)
        };
        stepFolder.add(stepActions, 'rollForward').name('X: กลิ้งไปหน้า (+90°)');
        stepFolder.add(stepActions, 'rollBackward').name('X: กลิ้งถอยหลัง (-90°)');
        stepFolder.add(stepActions, 'turnRight').name('Y: เลี้ยวขวา (-90°)');
        stepFolder.add(stepActions, 'turnLeft').name('Y: เลี้ยวซ้าย (+90°)');
        stepFolder.open();

        const manualFolder = gui.addFolder('MANUAL EDIT');
        manualFolder.add(myWheel.mesh.rotation, 'x', 0, Math.PI * 4).name('Rotation X').listen().onChange(() => myWheel.updateUI('Manual X Edit'));
        manualFolder.add(myWheel.mesh.rotation, 'y', -Math.PI, Math.PI).name('Rotation Y').listen().onChange(() => myWheel.updateUI('Manual Y Edit'));
        
        gui.add(myWheel, 'reset').name('RESET TO DEFAULT');

        function checkDevice() {
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                gui.close();
                if (window.innerWidth < 450) {
                    gui.width = window.innerWidth * 0.8;
                }
            } else {
                gui.open();
                gui.width = 300;
            }
        }

        checkDevice();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            checkDevice();
        });
    </script>
</body>
</html>
